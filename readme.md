# q1. js全局执行上下文为我们创建了两个东西：全局对象和this关键字
  new的实现原理：
    1. 创建一个空对象，构造函数的this指向这个空对象
    2. 这个新对象被执行【原型】连接
    3. 执行构造函数，将属性或方法添加到this引用的对象上
    4. 如果构造函数中没有返回其他对象，那么返回this，即创建的新对象。否则，返回构造函数返回的对象

# q2. call, bind, apply（修改作用域）
    1. b.call(a) 就相当于把b里面的作用域强行指向到a里面去
      第一个参数是要指向的地方，第二三...个参数是该作用域里用到的值 b.call(a, 5, 6...)
    2. b.apply(a, [9, 8, 3])  需要用到数组类型 
    3. b.call() || b.apply() 没有参数， 指向全局window
    4. c = b.call(a)
       c()
       bind方法返回的是一个修改过的函数，所以该用函数该有的姿态去调用
       bind方法接受的参数是按照形参的顺序进行的
    
#q3. 浅拷贝和深拷贝
    1. 数组解构：
      let [x, y] = [1, 2]
      // x = 1,
      // y = 2
    2. 对象解构：
      let { foo, bar } = { foo: "aaa", bar: "bbb" }
      // foo = "aaa"
      // bar = "bbb"
      另：（允许给赋值的变量重命名）
      let { foo: baz } = { foo: "abc" }
      // baz = "abc"
    3. 浅拷贝：只是第一层属性进行拷贝，当第一层的属性为基本数据类型时，新对象和原对象互不影响（不被修改）
       如果第一层的属性值是 # 复杂数据类型 #，那么新对象和原对象的属性值指向的是同一块内存地址

       深拷贝是将对象及值复制过来，两个对象修改其中任意一个的

#q4. 闭包
    让一个函数有权限访问另一个函数的变量
    所有的JavaSrcipt函数都是闭包，因为他们都是对象
    1.闭包的缺点就是常驻内存会增大内存使用量，并且使用不当容易造成内存泄漏
		2.如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。 

    1. 所有的JavaScript都是闭包
    2. 闭包是让一个函数A有权限访问另一个函数B的变量的函数 能访问其他函数的作用域
    3. 函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。
    4. 闭包存在的意义就是让我们可以间接访问函数内部的变量。闭包会阻止词法作用域的回收 js中有垃圾回收机制
    5. 所谓的词法作用域就是在你写代码时将变量和块作用域写在哪里来决定，也就是词法作用域是静态的作用域，在你书写代码时就确定了。
    6. 闭包就是能够读取其他函数内部变量的函数。闭包可以简单理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
    7. 它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。


    闭包是指有权限访问另一个函数作用域中的变量的函数
      1. 能够访问函数定义是所在的词法作用域（阻止其被回收）
      2. 私有化变量
      3. 模拟块级作用域
